var documenterSearchIndex = {"docs":
[{"location":"arrow-concepts/#Arrow-Related-Concepts/Conventions-1","page":"Arrow-Related Concepts/Conventions","title":"Arrow-Related Concepts/Conventions","text":"","category":"section"},{"location":"arrow-concepts/#","page":"Arrow-Related Concepts/Conventions","title":"Arrow-Related Concepts/Conventions","text":"note: Note\nIf you're a newcomer to Legolas.jl, please familiarize yourself with the tour before diving into this documentation.","category":"page"},{"location":"arrow-concepts/#","page":"Arrow-Related Concepts/Conventions","title":"Arrow-Related Concepts/Conventions","text":"Legolas.jl's target (de)serialization format, Arrow, already features wide cross-language adoption, enabling Legolas-serialized tables to be seamlessly read into many non-Julia environments. This documentation section contains conventions related to Legolas-serialized Arrow tables that may be observable by generic Legolas-unaware Arrow consumers.","category":"page"},{"location":"arrow-concepts/#Supporting-Legolas-Schema-Discovery-In-Arrow-Tables-1","page":"Arrow-Related Concepts/Conventions","title":"Supporting Legolas Schema Discovery In Arrow Tables","text":"","category":"section"},{"location":"arrow-concepts/#","page":"Arrow-Related Concepts/Conventions","title":"Arrow-Related Concepts/Conventions","text":"Legolas defines a special field legolas_schema_qualified that Legolas-aware Arrow writers may include in an Arrow table's table-level metadata to indicate a particular Legolas schema with which the table complies.","category":"page"},{"location":"arrow-concepts/#","page":"Arrow-Related Concepts/Conventions","title":"Arrow-Related Concepts/Conventions","text":"Arrow tables which include this field are considered to \"support Legolas schema discovery\" and are referred to as \"Legolas-discoverable\", since Legolas consumers may employ this field to automatically match the table against available application-layer Legolas schema definitions.","category":"page"},{"location":"arrow-concepts/#","page":"Arrow-Related Concepts/Conventions","title":"Arrow-Related Concepts/Conventions","text":"If present, the legolas_schema_qualified field's value must be a fully qualified schema identifier.","category":"page"},{"location":"arrow-concepts/#Arrow-File-Naming-Conventions-1","page":"Arrow-Related Concepts/Conventions","title":"Arrow File Naming Conventions","text":"","category":"section"},{"location":"arrow-concepts/#","page":"Arrow-Related Concepts/Conventions","title":"Arrow-Related Concepts/Conventions","text":"When writing a Legolas-discoverable Arrow table to a file, prefer using the file extension *.<unqualified schema name>.arrow. For example, if the file's table's Legolas schema is baz.supercar@1>bar.automobile@1, use the file extension *.baz.supercar.arrow.","category":"page"},{"location":"#API-Documentation-1","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"#","page":"API Documentation","title":"API Documentation","text":"note: Note\nIf you're a newcomer to Legolas.jl, please familiarize yourself with the tour before diving into this documentation.","category":"page"},{"location":"#","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Legolas","category":"page"},{"location":"#Legolas-Schemas-1","page":"API Documentation","title":"Legolas Schemas","text":"","category":"section"},{"location":"#","page":"API Documentation","title":"API Documentation","text":"Legolas.Schema\nLegolas.@schema\nLegolas.is_valid_schema_name\nLegolas.parse_schema_identifier\nLegolas.schema_name\nLegolas.schema_version\nLegolas.schema_identifier\nLegolas.schema_parent\nLegolas.schema_fields\nLegolas.schema_declaration\nLegolas.schema_declared\nLegolas.row","category":"page"},{"location":"#Legolas.Schema","page":"API Documentation","title":"Legolas.Schema","text":"Legolas.Schema{name,version}\n\nA type representing a Legolas schema. The name (a Symbol) and version (an Integer) are surfaced as type parameters, allowing them to be utilized for dispatch.\n\nFor more details and examples, please see Legolas.jl/examples/tour.jl and the \"Schema-Related Concepts/Conventions\" section of the Legolas.jl documentation.\n\nThe constructor Schema{name,version}() will throw an ArgumentError if version is not non-negative.\n\nSee also: Legolas.@schema\n\n\n\n\n\n","category":"type"},{"location":"#Legolas.@schema","page":"API Documentation","title":"Legolas.@schema","text":"@schema(\"name@version\", field_expressions...)\n@schema(\"name@version > parent_name@parent_version\", field_expressions...)\n\nDeclare a new Legolas.Schema{name,version} and overload relevant Legolas method definitions with schema-specific behaviors in accordance with the declared schema identifier, parent identifier (if present), and required fields.\n\nEach element of field_expressions defines a required field for the declared schema, and is an expression of the form field::F = rhs where:\n\nfield is the corresponding field's name\n::F denotes the field's type constraint (if elided, defaults to ::Any).\nrhs is the expression which produces field::F (if elided, defaults to field).\n\nAccounting for all of the aforementioned allowed elisions, possible valid forms of elements of field_expressions include:\n\nfield::F = rhs\nfield::F (interpreted as field::F = field)\nfield = rhs (interpreted as field::Any = rhs)\nfield (interpreted as field::Any = field)\n\nNote that:\n\nA Legolas.SchemaDeclarationError will be thrown if:\nThe provided schema identifier is invalid or is not a string literal\nIf there are no required field expressions, duplicate required fields are declared, or a given expression is invalid\n(if a parent schema is specified) This schema declaration does not comply with its parent's schema declaration, or the parent hasn't yet been declared\nThis macro expects to be evaluated within top-level scope.\n\nFor more details and examples, please see Legolas.jl/examples/tour.jl and the \"Schema-Related Concepts/Conventions\" section of the Legolas.jl documentation.\n\n\n\n\n\n","category":"macro"},{"location":"#Legolas.is_valid_schema_name","page":"API Documentation","title":"Legolas.is_valid_schema_name","text":"Legolas.is_valid_schema_name(x::AbstractString)\n\nReturn true if x is a valid schema name, return false otherwise.\n\nValid schema names are lowercase, alphanumeric, and may contain hyphens or periods.\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.parse_schema_identifier","page":"API Documentation","title":"Legolas.parse_schema_identifier","text":"Legolas.parse_schema_identifier(id::AbstractString)\n\nGiven a valid schema identifier id of the form:\n\n$(names[1])@$(versions[1]) > $(names[2])@$(versions[2]) > ... > $(names[n])@$(versions[n])\n\nreturn an n element Vector{Schema} whose ith element is Schema(names[i], versions[i]).\n\nThrows an ArgumentError if the provided string is not a valid schema identifier.\n\nFor details regarding valid schema identifiers and their structure, see the \"Schema-Related Concepts/Conventions\" section of the Legolas.jl documentation.\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.schema_name","page":"API Documentation","title":"Legolas.schema_name","text":"Legolas.schema_name(::Legolas.Schema{name})\n\nReturn name.\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.schema_version","page":"API Documentation","title":"Legolas.schema_version","text":"Legolas.schema_version(::Legolas.Schema{name,version})\n\nReturn version.\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.schema_identifier","page":"API Documentation","title":"Legolas.schema_identifier","text":"Legolas.schema_identifier(::Legolas.Schema)\n\nReturn this Legolas.Schema's fully qualified schema identifier. This string is serialized as the \"legolas_schema_qualified\" field value in table metadata for table written via Legolas.write.\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.schema_parent","page":"API Documentation","title":"Legolas.schema_parent","text":"Legolas.schema_parent(::Legolas.Schema)\n\nReturn the Legolas.Schema instance that corresponds to the parent of the given Legolas.Schema.\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.schema_fields","page":"API Documentation","title":"Legolas.schema_fields","text":"Legolas.schema_fields(schema::Legolas.Schema)\n\nReturn a NamedTuple{...,Tuple{Vararg{DataType}} whose fields take the form:\n\n<name of field required by schema> = <field's type>\n\nIf schema has a parent, the returned fields will include schema_fields(schema_parent(schema)).\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.schema_declaration","page":"API Documentation","title":"Legolas.schema_declaration","text":"Legolas.schema_declaration(schema::Legolas.Schema)\n\nReturn a Pair{String,Dict{Symbol,Expr}} of the form\n\nschema_identifier_used_for_declaration::String => required_field_expressions::Dict{Symbol,Expr}\n\nwhere each key-value pair in required_field_expressions takes the form:\n\nrequired_field_name::Symbol => normalized_required_field_assignment_statement::Expr\n\nNote that schema_declaration is primarily intended to be used for interactive discovery purposes, and does not include the contents of schema_declaration(schema_parent(schema)).\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.schema_declared","page":"API Documentation","title":"Legolas.schema_declared","text":"Legolas.schema_declared(schema::Legolas.Schema{name,version})\n\nReturn true if the schema name@version has been declared via @schema in the current Julia session; return false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.row","page":"API Documentation","title":"Legolas.row","text":"Legolas.row(schema::Schema; fields...)\nLegolas.row(schema::Schema, fields)\n\nReturn a Tables.AbstractRow-compliant value whose contents are provided by fields and validated/transformed in accordance with schema. If the non-keyword-arguments-based method is used, fields must be a Tables.AbstractRow-compliant value.\n\nFor more details and examples, please see Legolas.jl/examples/tour.jl.\n\n\n\n\n\n","category":"function"},{"location":"#Validating/Writing/Reading-Legolas-Tables-1","page":"API Documentation","title":"Validating/Writing/Reading Legolas Tables","text":"","category":"section"},{"location":"#","page":"API Documentation","title":"API Documentation","text":"Legolas.extract_legolas_schema\nLegolas.write\nLegolas.read","category":"page"},{"location":"#Legolas.extract_legolas_schema","page":"API Documentation","title":"Legolas.extract_legolas_schema","text":"Legolas.extract_legolas_schema(table)\n\nAttempt to extract Arrow metadata from table via Arrow.getmetadata(table).\n\nIf Arrow metadata is present and contains \"legolas_schema_qualified\" => s, return first(parse_schema_identifier(s))\n\nOtherwise, return nothing.\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.write","page":"API Documentation","title":"Legolas.write","text":"Legolas.write(io_or_path, table, schema::Schema; validate::Bool=true, kwargs...)\n\nWrite table to io_or_path, inserting the appropriate legolas_schema_qualified field in the written out Arrow metadata.\n\nIf validate is true, Legolas.validate will be called on the table before it written out.\n\nAny other provided kwargs are forwarded to an internal invocation of Arrow.write.\n\nNote that io_or_path may be any type that supports Base.write(io_or_path, bytes::Vector{UInt8}).\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.read","page":"API Documentation","title":"Legolas.read","text":"Legolas.read(io_or_path; validate::Bool=true)\n\nRead and return an Arrow.Table from io_or_path.\n\nIf validate is true, Legolas.read will attempt to extract a Legolas.Schema from the deserialized Arrow.Table's metadata and use Legolas.validate to verify that the table's Table.Schema complies with the extracted Legolas.Schema before returning the table.\n\nNote that io_or_path may be any type that supports Base.read(io_or_path)::Vector{UInt8}.\n\n\n\n\n\n","category":"function"},{"location":"#Utilities-1","page":"API Documentation","title":"Utilities","text":"","category":"section"},{"location":"#","page":"API Documentation","title":"API Documentation","text":"Legolas.lift\nLegolas.construct\nLegolas.guess_schema\nLegolas.assign_to_table_metadata!\nLegolas.gather\nLegolas.locations\nLegolas.materialize","category":"page"},{"location":"#Legolas.lift","page":"API Documentation","title":"Legolas.lift","text":"lift(f, x)\n\nReturn f(x) unless x isa Union{Nothing,Missing}, in which case return missing.\n\nThis is particularly useful when handling values from Arrow.Table, whose null values may present as either missing or nothing depending on how the table itself was originally constructed.\n\nSee also: construct\n\n\n\n\n\nlift(f)\n\nReturns a curried function, x -> lift(f,x)\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.construct","page":"API Documentation","title":"Legolas.construct","text":"construct(T::Type, x)\n\nConstruct T(x) unless x is of type T, in which case return x itself. Useful in conjunction with the lift function for types which don't have a constructor which accepts instances of itself (e.g. T(::T)).\n\nExamples\n\njulia> using Legolas: construct\n\njulia> construct(Float64, 1)\n1.0\n\njulia> Some(Some(1))\nSome(Some(1))\n\njulia> construct(Some, Some(1))\nSome(1)\n\nUse the curried form when using lift:\n\njulia> using Legolas: lift, construct\n\njulia> lift(Some, Some(1))\nSome(Some(1))\n\njulia> lift(construct(Some), Some(1))\nSome(1)\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.guess_schema","page":"API Documentation","title":"Legolas.guess_schema","text":"Legolas.guess_schema(table)\n\nReturns a Table.Schema matching the provided table if such a Tables.Schema can be determined, otherwise return nothing.\n\nThis function is similar to Tables.schema(table), but may undertake additional work to more aggressively attempt to determine a matching Table.Schema, even when it might not be directly evident from typeof(table).\n\nSpecifically, this function may call Tables.columns(table) as a preprocessing step.\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.gather","page":"API Documentation","title":"Legolas.gather","text":"Legolas.gather(column_name, tables...; extract=((table, idxs) -> view(table, idxs, :)))\n\nGather rows from tables into a unified cross-table index along column_name. Returns a Dict whose keys are the unique values of column_name across tables, and whose values are tuples of the form:\n\n(rows_matching_key_in_table_1, rows_matching_key_in_table_2, ...)\n\nThe provided extract function is used to extract rows from each table; it takes as input a table and a Vector{Int} of row indices, and returns the corresponding subtable. The default definition is sufficient for DataFrames tables.\n\nNote that this function may internally call Tables.columns on each input table, so it may be slower and/or require more memory if any(!Tables.columnaccess, tables).\n\nNote that we intend to eventually migrate this function from Legolas.jl to a more appropriate package.\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.locations","page":"API Documentation","title":"Legolas.locations","text":"locations(collections::Tuple)\n\nReturn a Dict whose keys are the set of all elements across all provided collections, and whose values are the indices that locate each corresponding element across all provided collecitons.\n\nSpecifically, locations(collections)[k][i] will return a Vector{Int} whose elements are the index locations of k in collections[i]. If !(k in collections[i]), this Vector{Int} will be empty.\n\nFor example:\n\njulia> Legolas.locations((['a', 'b', 'c', 'f', 'b'],\n                          ['d', 'c', 'e', 'b'],\n                          ['f', 'a', 'f']))\nDict{Char, Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}} with 6 entries:\n  'f' => ([4], [], [1, 3])\n  'a' => ([1], [], [2])\n  'c' => ([3], [2], [])\n  'd' => ([], [1], [])\n  'e' => ([], [3], [])\n  'b' => ([2, 5], [4], [])\n\nThis function is useful as a building block for higher-level tabular operations that require indexing/grouping along specific sets of elements.\n\n\n\n\n\n","category":"function"},{"location":"#Legolas.materialize","page":"API Documentation","title":"Legolas.materialize","text":"Legolas.materialize(table)\n\nReturn a fully deserialized copy of table.\n\nThis function is useful when table has built-in deserialize-on-access or conversion-on-access behavior (like Arrow.Table) and you'd like to pay such access costs upfront before repeatedly accessing the table.\n\nNote that we intend to eventually migrate this function from Legolas.jl to a more appropriate package.\n\n\n\n\n\n","category":"function"},{"location":"faq/#FAQ-1","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/#What-is-the-point-of-Legolas.jl?-Who-benefits-from-using-it?-1","page":"FAQ","title":"What is the point of Legolas.jl? Who benefits from using it?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"At its core, Legolas.jl provides a lightweight, expressive set of mechanisms/patterns for wrangling Tables.jl-compliant values in a manner that enables schema composability, extensibility and a few nice utilties on top.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"The package originated from code developed internally at Beacon to wrangling heterogeneous Arrow datasets, and is thus probably mostly useful for folks in a similar situation. If you're curating tabular datasets and you'd like to build shared Julia tools atop the schemas therein, then Legolas.jl may be worth checking out.","category":"page"},{"location":"faq/#Why-does-Legolas.jl-support-Arrow-as-a-(de)serialization-target,-but-not,-say,-JSON?-1","page":"FAQ","title":"Why does Legolas.jl support Arrow as a (de)serialization target, but not, say, JSON?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Technically, Legolas.jl's core row/Schema functionality is totally agnostic to (de)serialization and could be useful for anybody who wants to wrangle Tables.jl-compliant values.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Otherwise, with regards to (de)serialization-specific functionality, Beacon has put effort into ensuring Legolas.jl works well with Arrow.jl \"by default\" simply because we're heavy users of the Arrow format. There's nothing stopping users from composing the package with JSON3.jl or other packages.","category":"page"},{"location":"schema-concepts/#Schema-Related-Concepts/Conventions-1","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"","category":"section"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"note: Note\nIf you're a newcomer to Legolas.jl, please familiarize yourself with the tour before diving into this documentation.","category":"page"},{"location":"schema-concepts/#schema_identifier_specification-1","page":"Schema-Related Concepts/Conventions","title":"Schema Identifiers","text":"","category":"section"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"Legolas defines \"schema identifiers\" as strings of the form:","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"name@version where:\nname is a lowercase alphanumeric string and may include the special characters . and -.\nversion is a non-negative integer.\nor, x>y where x and y are valid schema identifiers and > denotes \"extends from\".","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"A schema identifier is said to be fully qualified if it includes the identifiers of all known ancestors of the particular schema that it directly identifies.","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"Schema authors should follow the below conventions when choosing the name part of a new schema's identifier:","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"Include a namespace. For example, assuming the schema is defined in a package Foo.jl, foo.automobile is good, automobile is bad.\nPrefer singular over plural. For example, foo.automobile is good, foo.automobiles is bad.\nDon't \"overqualify\" the schema name with ancestor-derived information. For example, bar.automobile@1>foo.automobile@1 is good, baz.supercar@1>bar.automobile@1 is good, bar.foo.automobile@1>foo.automobile@1 is bad, baz.automobile.supercar@1>bar.automobile@1 is bad.","category":"page"},{"location":"schema-concepts/#Schema-Versioning:-You-Break-It,-You-Bump-It-1","page":"Schema-Related Concepts/Conventions","title":"Schema Versioning: You Break It, You Bump It","text":"","category":"section"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"While it is fairly established practice to semantically version source code, the world of data/artifact versioning is a bit more varied. As presented in the tour, each Legolas.Schema has a single version integer. The central rule that governs Legolas' schema versioning approach is:","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"If an update is made to a schema that potentially requires existing data to be rewritten in order to comply with the updated schema, then the version integer associated with that schema should be incremented.","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"In other words: you break it, you bump it!","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"For example, a schema author must increment their existing schema's version integer if any of the following changes are made:","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"A new non->:Missing required field is added to the schema.\nAn existing required field's type restriction is tightened.\nAn existing required field is renamed.","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"One benefit of Legolas' approach is that multiple schema versions may be defined in the same codebase, e.g. there's nothing that prevents @schema(\"my-schema@1\", ...) and @schema(\"my-schema@2\", ...) from being defined and utilized simultaneously. The source code that defines any given Legolas schema and/or consumes/produces Legolas tables is presumably already semantically versioned, such that consumer/producer packages can determine their compatibility with each other in the usual manner via interpreting major/minor/patch increments.","category":"page"},{"location":"schema-concepts/#Important-Expectations-Regarding-Custom-Field-Assignments-1","page":"Schema-Related Concepts/Conventions","title":"Important Expectations Regarding Custom Field Assignments","text":"","category":"section"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"Schema authors should ensure that their schema declarations meet two important expectations so that Legolas' row function behaves as intended and inter-schema composability is preserved.","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"First, a schema's custom field assignments should preserve the idempotency of row invocations, such that the following holds for all valid values of fields:","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"row(schema, row(schema, fields)) == row(schema, fields)","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"Second, a schema's custom field assignments should not observe mutable non-local state, such that the following holds for all valid values of fields:","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"row(schema, fields) == row(schema, fields)","category":"page"},{"location":"schema-concepts/#How-to-Avoid-Breaking-Schema-Changes-1","page":"Schema-Related Concepts/Conventions","title":"How to Avoid Breaking Schema Changes","text":"","category":"section"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"It is preferable to avoid incrementing a schema's version integer (\"making a breaking change\") whenever possible to avoid code/data churn for consumers. Following the below guidelines should help make breaking changes less likely:","category":"page"},{"location":"schema-concepts/#","page":"Schema-Related Concepts/Conventions","title":"Schema-Related Concepts/Conventions","text":"Allow required fields to be Missing whenever reasonable.\nPrefer conservative field type restrictions from the get-go, to avoid needing to tighten them later.\nHandle/enforce \"potential deprecation paths\" in a required field's RHS definition when possible. For example, imagine a schema that contains a required field id::Union{UUID,String} = id where id is either a UUID, or a String that may be parsed as a UUID. Now, let's imagine we decided we wanted to update the schema such that new tables ALWAYS normalize id to a proper UUID. In this case, it is preferable to simply update this required field to id::Union{UUID,String} = UUID(id) instead of id::UUID = id. The latter is a breaking change that requires incrementing the schema's version integer, while the former achieves the same practical result without breaking consumers of old data.","category":"page"}]
}
