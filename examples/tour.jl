# This file provides an introductory tour for Legolas.jl. Run lines in the REPL
# to inspect output at each step! Tests are littered throughout to demonstrate
# functionality in a concrete manner, and so that we can ensure examples stay
# current as the package evolves.

using Legolas, Arrow, Tables, Test

using Legolas: @row

#####
##### Introduction to the `@row` Macro
#####
# The most interesting bit of Legolas.jl functionality is the package's `@row` macro, which callers can use
# define new [`Tables.AbstractRow`-compliant](https://tables.juliadata.org/stable/#Tables.AbstractRow-1)
# row types that exhibit some opinionated (but desirable!) properties w.r.t. composability/extensibility.
#
# These row type properties are fundamental to the wider data curation patterns that Legolas.jl seeks to
# facilitate, so let's explore them before we dig deeper into Legolas.jl's other table-centric utilities.

# Declare a `Legolas.Schema` with name `"my-schema"` at version `1` whose *required fields*
# `a`, `b`, `c`, `d`, and `e` are specified via the provided assignment expressions, then return
# a row type that matches the declared schema:
const MyRow = @row("my-schema@1",
                   a::Real = sin(a),
                   b::String = string(a, b, c),
                   c = [a, b, c],
                   d::Int,
                   e)

# `MyRow` is thus an alias for the type returned by the `@row` macro:
@test MyRow == Legolas.Row{typeof(Legolas.Schema("my-schema", 1))}

# The `MyRow` type has several useful constructors. Let's start with the constructor that
# accepts all required fields as keyword arguments:
row = MyRow(a=1.5, b="hello", c="goodbye", d=2, e=["anything"])

# By examining `row`'s fields, we can see how the assignment expressions from `MyRow`'s
# `@row` declaration were applied in a simple linear fashion to the input arguments:
@test row.a == sin(1.5)
@test row.b == string(sin(1.5), "hello", "goodbye")
@test row.c == [sin(1.5), string(sin(1.5), "hello", "goodbye"), "goodbye"]
@test row.d == 2
@test row.e == ["anything"]

# In fact, the field assignment expressions provided to the `@row` macro are interpolated
# nearly as-is into the underlying code generated by `@row`. For example, the relevant code
# generated by `MyRow`'s `@row` declaration looks roughly like:
#
#     function Legolas._transform(::typeof(Legolas.Schema("my-schema", 1));
#                                 a=missing, b=missing, c=missing, d=missing, e=missing,
#                                 other...)
#         a::Real = sin(a)
#         b::String = string(a, b, c)
#         c::Any = [a, b, c]
#         d::Int = d
#         e::Any = e
#         return (; a, b, c, d, e, other...)
#     end
#
# This `Legolas._transform` method is invoked at the core of the `MyRow` constructor. As you
# might have noticed, this method has two interesting properties we haven't yet demonstrated.
#
# Here we demonstrate the first property - required fields have a `missing` value by default:
@test isequal(MyRow(a=1.5, b="hello", c="goodbye", d=2), MyRow((; a=1.5, b="hello", c="goodbye", d=2, e=missing)))
@test_throws MethodError MyRow(a=1.5, b="hello", c="goodbye") # correctly throws a `MethodError` when evaluating `d::Int = missing`

# And here's a demonstration of the second property - callers may pass in any other fields in
# addition to the required fields:
row = MyRow(a=1.5, b="hello", c="goodbye", my_other_field=":)", d=2, e=["anything"])
@test row.my_other_field == ":)"

# Finally, there's also a `MyRow` constructor that accepts any `Tables.AbstractRow`-compliant value,
# and extracts all input fields from that value. Here, we demonstrate with a `NamedTuple`:
@test row == MyRow((a=1.5, b="hello", c="goodbye", d=2, e=["anything"], my_other_field=":)"))

#####
##### Extending Existing Rows/Schemas
#####
# Row types declared via `@row` can inherit the fields and transformations specified by other `@row`-declared types.
# Niftily, the properties we demonstrated above enable this extension mechanism to be implemented via composition
# under the hood.

# Declare a row type whose schema is named `"my-child-schema"` at version `1` that inherits the fields of the
# `my-schema@1` schema that we defined in the previous section.
const MyChildRow = @row("my-child-schema@1" > "my-schema@1",
                        f::Int = f + 1,
                        g::String,
                        c = last(c))

# The constructor for `MyChildRow` will first apply its parent's transformation before applying its own. The
# effect of this behavior can be seen clearly in the `c` field value in the following example:
input = (a=1.5, b="hello", c="goodbye", d=2, e=["anything"], f=3, g="foo")
child = MyChildRow(input)
@test child.a == sin(1.5)
@test child.b == string(sin(1.5), "hello", "goodbye")
@test child.c == "goodbye"
@test child.d == 2
@test child.e == ["anything"]
@test child.f == 4
@test child.g == "foo"

# A note on syntax: You might ask "Why use `>` as the inheritance operator instead of `<:`?" There are actually three reasons. Firstly,
# `<:` is canonically a subtyping operator that implies the Liskov substition principle, but because Legolas allow arbitrary RHS code in
# required field declarations, a "child" row is not de facto substitutable for its parent. Secondly, `>` implies the actual ordering that
# row transformations are applied in; the parent transformation comes before the child transformation. Thirdly, the child row will usually
# (though technically not always) have a greater total number of required fields than the parent row.

#####
##### Reading/Writing/Validating `Arrow.Table`s with Legolas.jl
#####
# TODO

#####
##### Simple Integer Versioning: You Break It, You Bump It
#####
# TODO

#####
##### Tips For Schema Design
#####
# TODO: Cover the following:
#
#   - forward/backward compatibility via allowing `missing` columns when possible
#   - avoid bumping schema versions by handling the deprecation path in the constructor
#   - prefer idempotency in field expressions when possible
#   - prefer Liskov substitutability when possible

#####
##### Miscellaneous Utilities
#####
